// FETCHING VARIABLES.....
const container =document.querySelector('.wrapper');

//search-bar-container
const searchbar=document.querySelector('.searchbar-container');

//profile-container
const profilecontainer=document.querySelector('.profile-container');

//inline-style:-the variable 'root' holds a reference to the inline style of the <html> element, allowing you to manipulate its CSS properties directly through JavaScript.
//'documentElement': This property returns the root element of the document, which in HTML is the <html> element.
const root = document.documentElement.style;

//URL API
const url = "https://api.github.com/users/";

//Creating a function (get) which takes an argument and in that function we use document.getelementbyclass and pass that argument in template literals so that exactly same class name element is fetched.
const get=(parameter)=>document.getElementsByClassName(`${parameter}`);

const noresults=get('no-results')[0];
const btnmode=get('btn-mode')[0];
const modetext=get('mode-text')[0];
const modeicon=get('mode-icon')[0];


//NOTE:- The get function used to select the elements with document.getElementsByClassName returns an HTMLCollection, not a single element. This means we need to access the first element in the collection using an index, like get("btn-search")[0].If we use id to fetch then there is no need to use this.



const btnsubmit = get("btn-search")[0];
const input = get("input-class")[0];
const avatar = get("avatar")[0];
const userName = get("name")[0];
const user = get("user")[0];
const date = get("date")[0];

//Creating an array containing all months name
const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

const bio = get("bio")[0];
const repos = get("repos")[0];
const followers = get("followers")[0];
const following = get("following")[0];
const user_location = get("location")[0];
const page = get("page")[0];
const twitter = get("twitter")[0];
const company = get("company")[0];
const errContainer=get('error-container')[0];
const errMsg=get('err-msg')[0];
const errClass=get('error')[0];
// setting a variable to false
let darkMode = false;

// EVENT-LISTENERS

// Event Listener on submit button/search button
btnsubmit.addEventListener('click' ,  function(){
    //If  input field is not null,then call getUserData() function and pass url and input text as parameter
    if(input.value!==''){
        getUserData(url + input.value); 
        /*N-O-T-E:-In the line getUserData(url + input.value);, the + operator is being used for concatenation.
         
        Here's what's happening:

url is a string variable containing a URL.
input.value is a property that likely holds the value of an HTML input element.
url + input.value concatenates these two strings together.
For example, if url is "https://example.com/" and input.value is "search", then url + input.value would result in "https://example.com/search".

*/
     }
 });

//EVENT LISTENER ON INPUT FILED IF 'ENETR' KEY IS PRESSED
/*
(1):-keydown Event:

This event fires when a key is pressed down.
It triggers immediately after the key is pressed, before the key generates any character output.
It captures all keys, including non-printable keys like Shift, Alt, Ctrl, Arrow keys, etc.
Useful for capturing key combinations (e.g., Ctrl + A) and for actions that need to respond to immediate key press events.
Can be used to capture keys like Tab or Arrow keys for navigation purposes.

(2):-keyup Event:

This event fires when a key is released after being pressed.
It triggers after the key is released.
It's useful for detecting when a user has finished typing a character or releasing a specific key.
Often used for actions that should occur after a key has been pressed and released.


(3):-keypress Event:

This event is triggered when a key that produces a character value is pressed down. This includes letters, numbers, symbols, etc.
It doesn't capture non-printable keys like Shift, Alt, Ctrl, Arrow keys, etc.
It's useful for capturing textual input, as it provides the character generated by the key press.
In modern browsers, keypress is considered deprecated in favor of input events for text input fields. However, it can still be useful in some cases, especially for handling keyboard shortcuts involving printable characters.
*/
input.addEventListener('keydown',(e)=>{//passing event 'e' as argument
   //if the pressed key is 'Enter'
    if(e.key=='Enter'){
        //Check ist if the input field is not empty
        if(input.value!=='') //if not empty,then pass the url along with input-value in concatenation to getUserData() function
        {
            
            getUserData(url + input.value);
        }
    }
});

//ADDING EVENT LISTENER(input) ON INPUT FIELD SO THAT WHEN SOMETHING IS WRITTEN ON IT,THE TEXT MESSAGE OF 'NO RESULTS FOUND' VANISHES
input.addEventListener('input',()=>{
    noresults.classList.remove('vista');
});

//Adding event listener on 'div' element containing dark and ligh mode
btnmode.addEventListener('click',()=>{
    if(darkMode==false){
        //When clicked,if dark mode is set to false(which is default) meaning light mode is active,then invoke function darkModeProperties() else invoke lightModeProperties
        darkModeProperties();
       
    }   
    else{
        lightModeProperties();

    }
   
});



//DEFINING getUserData() FUNCTION:-
async function getUserData(gitUrl){
try{
     let response=await fetch(gitUrl);
     if(!response.ok){
        if (response.status === 404) {
            throw new Error('404');
        }
        else
        throw new Error(`Error Occured,error status:${response.status},error message:${response.text}`);
     }
     else{
        const data=await response.json();
        //Displaying data to check which particular item is located within what parent so that we could fetch them later and use on to display them.
        console.log(data);
        //Invoking Function Which displays this data on UI
        updateProfile(data);
     }
}
catch(err){

    //Before displaying error,hiding the profile-container
    // profilecontainer.style.display='none';
    /*
       (1):-  err instanceof TypeError:

This part checks if the err variable is an instance of the TypeError class. In JavaScript, errors are often represented as instances of various Error classes (TypeError, ReferenceError, SyntaxError, etc.). Checking if err is an instance of TypeError ensures that the error object belongs to the expected error type.


(2):- err.message.includes('Failed to fetch'):

This part checks if the error message contained in the err object includes the substring 'Failed to fetch'. The message property of an error object typically contains a description of the error. The includes() method is used here to determine if the error message contains the specified substring.

    */
       if(err instanceof TypeError && err.message.includes('Failed to fetch')){
      //Adding error message to element
      noresults.textContent='NETWORK ERROR !!';
      
       noresults.classList.add('tracking-[1px]');
    
    noresults.classList.add('vista');
       setTimeout(()=>{
        noresults.classList.remove('vista');
    },3000);
  
    
       }
       else if(err.message.includes('404')){
        noresults.textContent='PROFILE NOT FOUND !!'; 
    //    noresults.style.display='block';
        
        //pr-8 class added to make the cut icon(x) visible in input field
        // noresults.classList.add('opacity-100' , 'visible','scale-100');
        //  noresults.style.display='block';
        noresults.classList.add('vista');
        setTimeout(()=>{
        //  noresults.style.display='none';
        //   noresults.classList.remove('opacity-100' , 'visible','scale-100');
        noresults.classList.remove('vista');
     },3000);
      
         
       }

       else{
        noresults.textContent='UnExpected Error Occurred !';
        //  noresults.style.display='block';
        noresults.classList.add('vista');
       setTimeout(()=>{
        noresults.classList.remove('vista')
    },3000);
       }
       
       

  }
}


//Creating updateProfile() function which displays data on UI
function updateProfile(data){
    //Ist check if data exists,if exists then hide the No search results text
    if(data.message!== 'Not Found'){
        noresults.classList.remove('vista');

    /*
    Now here we create a function having 2 parameters,one is the element(like Location) and the other parameter is it's value that we fetch from API e:g checkNull(value,element).....Now since if the value of the element that we fetched is empty or null,we want the element to appear faded,parameter1 will be value and parameter 2 will be the element itself.This function will return false if value is empty or null and true if value is present.

    NOTE:-   THIS FUNCTION checkNull() is meant for bottom-icons and elemnts.

    */
   function checkNull(parameter1,parameter2){
    if(parameter1==='' || parameter1===null){
        parameter2.style.opacity=0.5;
    /* Now we need to set the opacity of the image representing parameter2 such as loaction image for location as well which is it's previous sibling element.
   (*):-Previous Sibling Element:-the "previous sibling element" refers to the element immediately preceding a given element within the same parent element.
Every HTML element in the DOM (Document Object Model) is considered a node, and they are arranged in a hierarchical structure. Sibling elements are elements that share the same parent element.e:g-

<div id="parent">
  <p>First paragraph</p> <!-- Previous sibling of the <span> element below -->
  <span>This is a span</span> <!-- Target element -->
  <div>Another div</div>
</div>
   */
  parameter2.previousElementSibling.style.opacity=0.5;
  return false;
    }
else return true;
   }
   
   //Adding user image to UI
   avatar.src=`${data.avatar_url}`;

   //Adding User-name.
   /*
   N-O-T-E:-Ternary Operator in J.S:-The ternary operator, also known as the conditional operator, is a compact way of expressing conditional logic in many programming languages, including JavaScript. It's often used as a concise alternative to an if...else statement. The syntax of the ternary operator is as follows:
        
   condition ? expressionIfTrue : expressionIfFalse

(*) condition: This is the condition that you want to evaluate. If the condition is true, the expression before the : (colon) is evaluated. If the condition is false, the expression after the : is evaluated.

(*) expressionIfTrue: This is the expression that is returned if the condition evaluates to true.

(*) expressionIfFalse: This is the expression that is returned if the condition evaluates to false.
   
Since below we are trying to display user name so if user name ===null we will display login name then else we will display username.
   */
   userName.innerText=data.name === null ? data.login : data.name;

   //Adding github profile name as in login name
   user.innerText=`@${data.login}`;
   //Adding github url
   user.href=`${data.html_url}`;

   //NOTE:-Template literals (enclosed by backticks, `) allow for embedded expressions, making it easy to include variables and expressions within a string. They are particularly useful when constructing strings that include variable values or need to be concatenated with other strings.Thus here is some cases we used template literals even when there was no need for it,so it is just for readability.Any fetched output which is already a string and no variable is needed to concatenate with it,there is no need to use template literal e:g data.html_url is already string and we do not have to concatenate anything with it so there is no need to use template literal here.


   //FETCHING DATE:-
/*
"created_at": "2009-07-11T21:45:18Z",.This is present in fetched 'data' object where created_at is the string variable which contains date,so we will use split('T') method to split the date string upto charcater 'T' which will give us an array of 2 items containing ['2009-07-11' , '21:45:18Z'] ,Then we use shift() method which removes and returns the first element of the array, which is the date part ("2009-07-11") and converts it to string and then we again use split('-') method and split the string into array on the basis of hyphen(-) which will also result in an array containing 3 elements as ['2009' , '07' , '11'] and using index we can fetch the date from array.

Full Breakdown:

(*)--> data.created_at:
This is the input date string, which is in ISO 8601 format (e.g., "2009-07-11T21:45:18Z").
.split("T"):
The split("T") method is called on the data.created_at string. This splits the string into an array of two substrings at the "T" character:
The first part (before the "T") is the date (e.g., "2009-07-11").
The second part (after the "T") is the time (e.g., "21:45:18Z").
Resulting array: ["2009-07-11", "21:45:18Z"].


(*)--> .shift():

The shift() method is called on the array resulting from the split. This removes and returns the first element of the array, which is the date part ("2009-07-11").
After this, we have the string: "2009-07-11".
.split("-"):

(*)--> The split("-") method is called on the date string ("2009-07-11"). This splits the date string into an array of substrings at each hyphen ("-"):
Resulting array: ["2009", "07", "11"].
*/
//Defining variable dateSegments which refer to array containing date segments
const dateSegments = data.created_at.split("T").shift().split("-");

//Adding Joining date to U.I.Note that 'months' is an array defined above with ist month name at 0th index and thus if datesegments[0]=8 which means 8th month in august which will be at 7th index in months array,so we subtract 1.
    date.innerText=`Joined: ${dateSegments[2]} ${months[dateSegments[1] - 1]}  ${dateSegments[0]} `;


//ADDING bio.
bio.innerText= data.bio === null ? "This profile has no bio" : data.bio;

//Adding Repos:-
repos.innerText=data.public_repos;

//Adding followers and Following
followers.innerText = data.followers;
following.innerText = data.following;

//Adding user-location using checkNUll() function.While this function displays user-location if present,meanwhile it sets opacity of elements to 0.5 as well if doesn't exist and displays not available.
user_location.innerText = checkNull(data.location , user_location) ? data.location : "Not Available";

//Adding website(BLOG)
page.innerText = checkNull(data.blog , page) ? data.blog : 'Not Available';

//Adding 'url' for website 
page.href=checkNull(data.blog,page) ? data.blog : '#';

//Adding twitter profile and twitter link
twitter.innerText=checkNull(data.twitter_username , twitter) ? data.twitter_username : 'Not Available';
twitter.href=checkNull(data.twitter_username , twitter) ? `https://twitter.com/${data.twitter_username}`: '#';

//Adding Company Name
company.innerText=checkNull(data.company,company) ? data.company : 'Not Available';

//Since if the data exists,we need to make sure to display searchbar and profile container.THIS STEP MAY NOT BE NECESSARY
searchbar.classList.toggle('active');
profilecontainer.classList.toggle('active');

} //if-statement of updateProfile() ends

else {
    //display no results
    // noresults.innerText='No Search Results';
    noresults.classList.toggle('vista');
}

} //updateProfile() ends

//SETTING THE DRAK MODE AS DEFAULT.HERE WE CHECK FOR THE USER'S PREFRENCE OF MODE,IF THE USER HAS ALREADY SET HIS SYSTEM TO DARK MODE THEN THE DARK MODE WILL BE DISPLAYED ELSE LIGHT MODE WILL BE DISPLAYED.
const prefersDarkMode = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;

/*
(*):- EXPLAINATION OF ABOVE CODE:-
This line of code is checking if the user's system prefers a dark color scheme, but it does so with a built-in safeguard to ensure compatibility with browsers that may not support window.matchMedia. 

(*):- window.matchMedia: This is a method that returns a MediaQueryList object. This object can be used to determine if the document matches the media query string. In this case, the media query string is "(prefers-color-scheme: dark)", which checks if the user has set their operating system to use a dark theme.Thus window.matchMedia returns a media query list object which also informs us that window.matchMedia is supported.

(*):-window.matchMedia("(prefers-color-scheme: dark)").matches: If window.matchMedia exists (i.e., the browser supports it), this part of the code is executed. It calls window.matchMedia with the media query "(prefers-color-scheme: dark)". The matches property of the returned MediaQueryList object is a boolean indicating if the document currently matches the media query.Thus prefersDarkMode stores a boolean value,true if mwindow.matchMedia feature is supported and media query is set to 'prefers-color-scheme: dark'.
*/

//Now we check if the system storage already has stored any value(true/false) for key 'dark-mode'.Intially there will be no key as 'dark-mode' in system storage,So we put this key in system storage based on value we recieve from prefersDarkMode.If prefersDarkMode came as true,then dark-mode key stores true else false.
if(localStorage.getItem('dark-mode'))//means is dark-mode=true; in local storage
{
    //Setting the value of dark-mode key into variable darkMode
    darkMode=localStorage.getItem('dark-mode');
    //Now we got the value that dark-mode=true,so calling darkModeProperties() function
    darkModeProperties();

}
else{
    //If the prefersDrakMode is false,then store key 'dark-mode' in local storage with false value and call lightModeProperties() function.
    localStorage.setItem('dark-mode',prefersDarkMode);
    darkMode=prefersDarkMode;//setting the value false to darkMode
    lightModeProperties();
}

//Defining darkModeProperties()
function darkModeProperties(){
   // Setting styles for dark mode in root element
        root.setProperty("--lm-bg", "#141D2F");
        root.setProperty("--lm-bg-content", "#1E2A47");
        root.setProperty("--lm-text", "white");
        root.setProperty("--lm-text-alt", "white");
        root.setProperty("--lm-shadow-xl", "rgba(70,88,109,0.15)");
        //in dark mode,show text for light mode
        modetext.innerText = "LIGHT";
        modeicon.src = "./assets/images/sun-icon.svg";
        root.setProperty("--lm-icon-bg", "brightness(1000%)");
        darkMode = true;
        localStorage.setItem("dark-mode", true);
        // document.body.classList.add('transition-colors','duration-300');
}
function lightModeProperties() {
    root.setProperty("--lm-bg", "#F6F8FF");
    root.setProperty("--lm-bg-content", "#FEFEFE");
    root.setProperty("--lm-text", "#4B6A9B");
    root.setProperty("--lm-text-alt", "#2B3442");
    root.setProperty("--lm-shadow-xl", "rgba(70, 88, 109, 0.25)");
    modetext.innerText = "DARK";
    modeicon.src = "./assets/images/moon-icon.svg";
    root.setProperty("--lm-icon-bg", "brightness(100%)");
    darkMode = false;
    localStorage.setItem("dark-mode", false);
  }
  getUserData(url + "thepranaygupta");

